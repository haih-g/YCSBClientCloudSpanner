#!/usr/bin/env node

const bounds = require('binary-search-bounds');
const dedent = require('dedent');
const fs = require('fs');
const path = require('path');
const Spanner = require('@google-cloud/spanner');
const stats = require('stats-lite');

const Workload = require('../workload');

require('yargs')
  .version(false)
  .strict()
  .command(
    'run [args]',
    'Run the workload',
    {
      P: {
        alias: 'workload',
        type: 'string',
        description: 'The path to a YCSB workload file',
        coerce: parseWorkloadFile
      },
      p: {
        alias: 'parameter',
        description: 'The key=value pair of parameter',
        coerce: parseKeyValuePairs
      },
      b: {
        alias: 'num_bucket',
        default: 1000,
        type: 'number',
        describe: 'The number of buckets in output'
      }
    },
    runWorkload
  ).argv;

function formatOptions(argv) {
  const options = argv.workload.concat(argv.parameter, [
    ['numBucket', argv.num_bucket]
  ]);

  return new Map(options);
}

function parseKeyValuePairs(pairs) {
  return pairs.map(pair => pair.split('='));
}

function parseWorkloadFile(filePath) {
  const contents = fs.readFileSync(path.resolve(filePath));
  return parseKeyValuePairs(contents.toString().split('\n'));
}

function printMetrics(workload) {
  const numBucket = workload.options.get('numBucket');
  const operationCount = workload.options.get('operationcount');

  let totalOps = 0;

  workload.operations.forEach(operation => {
    totalOps += workload.latencies[operation].length;
  });

  console.log(
    dedent`[OVERALL], RunTime(ms), ${workload.duration}
    [OVERALL], Throughput(ops/sec), ${totalOps / workload.duration}`
  );

  workload.operations.forEach(operation => {
    const lats = workload.latencies[operation];
    const ops = lats.length;
    const opName = `[${operation.toUpperCase()}]`;

    console.log(
      dedent`${opName}, Operations ${operationCount}
      ${opName}, AverageLatency(us), ${stats.mean(lats)}
      ${opName}, LatencyVariance(us), ${stats.stdev(lats)}
      ${opName}, MinLatency(us), ${Math.min(...lats)}
      ${opName}, MaxLatency(us), ${Math.max(...lats)}
      ${opName}, 95thPercentileLatency(us), ${stats.percentile(lats, 0.95)}
      ${opName}, 99thPercentileLatency(us), ${stats.percentile(lats, 0.99)}
      ${opName}, 99.9thPercentileLatency(us), ${stats.percentile(lats, 0.999)}
      ${opName}, Return=OK ${ops}`
    );

    for (let i = 0; i < numBucket; i++) {
      let hi = bounds.lt(lats, i + 1);
      let lo = bounds.le(lats, i);
      console.log(`${opName}, ${i}, ${hi - lo}`);
    }

    let lo = bounds.le(lats, numBucket);
    console.log(`${opName}, ${numBucket}, ${ops - lo}`);
  });
}

function runWorkload(argv) {
  const options = formatOptions(argv);

  const spanner = new Spanner({
    projectId: options.get('cloudspanner.project')
  });

  const database = spanner
    .instance(options.get('cloudspanner.instance'))
    .database(options.get('cloudspanner.database'));

  const workload = new Workload(database, options);

  return workload
    .loadKeys()
    .then(() => workload.run())
    .then(() => printMetrics(workload))
    .catch(err => console.error(err));
}
